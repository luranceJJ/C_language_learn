
#if 0

【储存类的定义】
存储类定义 C 程序中变量/函数的存储位置、生命周期和作用域。
    auto
    register
    static
    extern


【auto 存储类】：
auto 存储类是所有局部变量默认的存储类。
定义在函数中的变量默认为 auto 存储类，这意味着它们在函数开始时被创建，在函数结束时被销毁。
    void fun(void)
    {
        int a; // 省略auto
        auto int b;  // 因为函数内局部变量都是auto类型，所以一般是不会这么写
    }


【register 存储类}：
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。
这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），
且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

register 存储类定义存储在寄存器，所以变量的访问速度更快，
但是它不能直接取地址，因为它不是存储在 RAM 中的。
在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。
    {
    register int  miles;
    }
寄存器只用于需要快速访问的变量，比如计数器。
特别注意：定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。



【static 存储类】：
static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。
因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 的作用：
    1.修饰局部变量（称为静态局部变量）  // 变量的作用域限制在声明它的函数内
    2.修饰全局变量（称为静态全局变量） // 变量的作用域限制在声明它的文件内
    3.修饰函数（称为静态函数）  //限制函数只在本文件中使用。除非是外部可调用的函数，其它都应加static修饰函数，这是一个好习惯
特别之处：静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。

【内存分区概念】
内存可分为栈区、堆区、静态区（也可称为全局区）等。
栈区存放函数的参数值、局部变量的值等，这些数据进入作用域创建，出作用域被销毁。
堆区用于动态内存分配等。
静态区存储全局变量和静态变量，这些变量创建好后，直到程序结束后才释放。

【extern 存储类】：
extern 存储类用于定义在其他文件中声明的全局变量或函数。
当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，
可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，
extern 是用来在另一个文件中声明一个全局变量或函数

特别注意：C语言程序是从第一行开始编译运行的，所以变量、函数一般都需要在文件头声明，
或者确保变量放在文件头，且确保不被引用；


【C 语言中全局变量、局部变量、静态全局变量、静态局部变量的区别】：
从作用域看：
1、全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。
2、静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
3、局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
4、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

从分配内存空间看：
1、全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间
2、全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
 1)静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
 2)变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。
从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

Tips:
 A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
 B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
 C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
 D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带"内部存储器"功能的的函数)
 E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

#endif

#include <stdio.h>

#if 0
// 错误的使用方法
int fun(int x)
{
    return x*pi;  // 这里会报错，因为pi未定义，因为它在函数下方定义
}

int pi = 3;
#endif

#if 0
// 正确的使用方法1
int pi = 3;
int fun(int x)
{
    return x*pi;  
}
#endif

#if 1
// 正确的使用方法2
extern int pi;  // 在文件头声明变量 
int fun(int x)
{
    return x*pi;  
}

int pi = 3;
#endif

int main(int argc, char const *argv[])
{
    printf("pi:%d, fun(%d):%d\n", pi, pi, fun(pi));

    return 0;
}